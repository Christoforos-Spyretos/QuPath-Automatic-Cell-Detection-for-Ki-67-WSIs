'''
python new_summary_ratios.py --maps_dir /local/data1/chrsp39/QuPath_Portable/results --norm_maps_dir Normalized_Maps/ --result_dir Test_Results/ --data_dir /local/data1/chrsp39/QuPath_Portable/Project/data --csv_path /local/data1/chrsp39/QuPath_Portable/CBTN_KI67.csv --WSIs_path /local/data2/chrsp39/CBTN_v2/new_KI67/WSI
'''

# %% IMPORTS
import json
import os
import numpy as np
import math
import pandas as pd
import argparse
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image

# %% ARGUMENT PARSING
parser = argparse.ArgumentParser(description='Create summary rations and density maps.')
parser.add_argument('--maps_dir', type=str, default=False, help='Directory of the cell density maps generated by QuPath.')
parser.add_argument('--data_dir', type=str, default=False, help='Directory of the project data')
parser.add_argument('--csv_path', type=str, required=True, help='Path to the WSI dataframe CSV file')
parser.add_argument('--WSIs_path', type=str, default=False, help='Directory of the folder where the WSIs exist.')
parser.add_argument('--norm_maps_dir', type=str, default=False, help='Directory to save the normalized cell density maps.')
parser.add_argument('--result_dir', type=str, default=False, help='Directory to save the summary of experiments.')
args = parser.parse_args()

# %% DIRECTORIES & FILES NEEDED FOR THE ANALYSIS
maps_dir = args.maps_dir
data_dir = args.data_dir
csv_path = args.csv_path
# check if the CSV file exists
if not os.path.isfile(csv_path):
    raise FileNotFoundError(f"The specified CSV file does not exist: {csv_path}")
WSI_df = pd.read_csv(csv_path)
WSIs_path = args.WSIs_path
norm_maps_dir = args.norm_maps_dir
# create the directory to save the normalised maps if it does not exist
if not os.path.exists(norm_maps_dir):
    os.makedirs(norm_maps_dir)
result_dir = args.result_dir
# create the directory to save the results if it does not exist
if os.path.exists(result_dir) == False:
    os.makedirs(result_dir)
# get the area and total detections
annotation_df = pd.read_csv("bin/Area_Det.txt",names=['name', 'detections', 'area'],delimiter=";",index_col=False) 

# %% RETRIEVE INFORMATION FROM JSON FILES 
file_list = [f for f in os.listdir(data_dir) if os.path.isdir(os.path.join(data_dir,f))]
WSIs = os.listdir(WSIs_path)

# data frame to store the results
results_df = pd.DataFrame(columns = ['case_id', 'slide_id', 'label', 'Positive', 'Pos_Density', 'Negative', 'Neg_Density', 'Pos_Percentage', 'Density'])

proc_l = len(file_list)
proc = -1
failed_list = []
failed_ann = []
for folder in file_list:
    proc += 1
    # proc_perc = round(proc/proc_l*100, 2)
    # print('Progress: ' + str(proc_perc) + '%') 
    print('Processing image ' + str(proc) + ' of ' + str(proc_l))
    with open(data_dir + '/' + folder + '/server.json', 'r') as s_file:
        server_data = json.load(s_file)
        slide_id = server_data['builder']['metadata']['name'][:-4]
        case_id = slide_id.split('___')[0] 
    
    label = WSI_df['label'].loc[WSI_df['slide_id']==slide_id].values[0]
   
    # survival = WSI_df['survival'].loc[WSI_df['slide_id']==im_name] 
    print('Reading data from image ' + slide_id + ':')
    with open(data_dir + '/' + folder + '/summary.json', 'r') as file:
        data = json.load(file)
        detection_data = data['hierarchy']['detectionClassificationCounts']
        if 'Positive' not in detection_data.keys():
            print('The slide has not been properly segmented yet, skipping.')
            failed_list.append(slide_id)
            continue

        pos_count = detection_data['Positive']
        neg_count = detection_data['Negative']
        # round ratio to 2 decimal places
        ratio = round(pos_count / (pos_count + neg_count), 2)
        
        for WSI in WSIs:
            WSI_name = WSI.split('.')[0]
            if slide_id in WSI_name:
                slide_file_name = WSI
                print('Found the corresponding WSI file: ' + slide_file_name)
                break

    try:
        annAreamm = annotation_df['area'].loc[annotation_df['name'] == slide_file_name].values[0]*0.000001
        numdet = annotation_df['detections'].loc[annotation_df['name'] == slide_file_name].values[0]
        cells_smm = numdet/annAreamm
        p_cellD = pos_count/annAreamm
        n_cellD = neg_count/annAreamm
    except:
        print('Could not find any annotation data.')
        failed_ann.append(slide_file_name)
    else:
        print("Area of the segmented tissue: " + str(annAreamm))
        print("Total number of detections: " + str(numdet))
        print('Number of detections per mm^2: ' + str(cells_smm))
    
    results_df.loc[len(results_df)] = [case_id, slide_id, label, pos_count, p_cellD, neg_count, n_cellD, ratio*100, cells_smm] 
    print('Positive cell count: ' + str(pos_count))
    print('Negative cell count: ' + str(neg_count))
    print('Positive to negative ratio: ' + str(ratio))

# %% GENERATE THE NORMALISED AND RATIO CELL DENSITY MAPS
    # get the cell density maps generated by QuPath
    HM_file_neg = maps_dir + '/' + slide_id + '_NegDMap.tif'
    HM_file_pos = maps_dir + '/' + slide_id + '_PosDMap.tif'

    failed_cell_density_list = []

    # check if both cell density map files exist before proceeding
    if os.path.isfile(HM_file_neg) and os.path.isfile(HM_file_pos):
        neg_pp_im = norm_maps_dir + '/' + slide_id + '_NegCellDM.png'
        pos_pp_im = norm_maps_dir + '/' + slide_id + '_PosCellDM.png'
        ratio_pp_im = norm_maps_dir + '/' + slide_id + '_Ratio.png'

        # generate the negative normalised cell density map
        if not os.path.isfile(neg_pp_im):
            print("Generating normalized negative cell density map.")
            # negative image
            im = Image.open(HM_file_neg)
            width, height = im.size
            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'

            # adjust values to optimize the visualization of the heat map:
            imarray = np.array(im)
            cm_lim = np.max(imarray)

            # uncomment next part if 95% normalization is desired:
            # relevant_values = imarray[imarray > 0] # Only take into account foreground pixels
            # n_relval = len(relevant_values)
            # adjusted_n_relval = round(n_relval*0.95)
            # sorted_relval = sorted(relevant_values)
            # cm_lim = max(sorted_relval[:adjusted_n_relval])
            max_val_neg = 500
            new_imarray = imarray/max_val_neg
            # keep values inside normalized range for a correct comparison between heat maps
            new_imarray[new_imarray>1] = 1 

            neg_imarray = imarray
            # prepare cell density map for saving:
            cmapQ = plt.get_cmap('jet')
            A = cmapQ(new_imarray)

            fig, ax = plt.subplots()
            # assign colorbar:
            norm = matplotlib.colors.Normalize(vmin=0, vmax=max_val_neg)  # cm_lim) 
            plt.imshow(A)
            cb = fig.colorbar(plt.cm.ScalarMappable(norm, cmap='jet'), ax = ax, orientation = orient)

            # save negative cell density map:
            plt.title('Negative Cell Density Map')
            plt.savefig(neg_pp_im)
            cb.remove()
            plt.close("all")
        else:
            print("Normalized negative cell density map already exists, skipping.")

        # generate the positive normalised cell density map
        if not os.path.isfile(pos_pp_im):
            print("Generating normalized positive cell density map.")
            # positive cell density image
            im = Image.open(HM_file_pos)

            width, height = im.size
            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'

            # adjust values to optimize the visualization of the heat map:
            imarray = np.array(im)
            cm_lim = np.max(imarray)

            # uncomment next part if 95% normalization is desired:
            # relevant_values = imarray[imarray > 0] # Only take into account foreground pixels
            # n_relval = len(relevant_values)
            # adjusted_n_relval = round(n_relval*0.95)
            # sorted_relval = sorted(relevant_values)
            # cm_lim = max(sorted_relval[:adjusted_n_relval])
            # if 'GFAP' in slide_id:
            #     max_val_pos = 500
            # else:
            #     max_val_pos = 50
            max_val_pos = 50
            # normalize with obtained value
            new_imarray = imarray/max_val_pos # /cm_lim 
            # keep values inside normalized range for a correct comparison between heat maps
            new_imarray[new_imarray>1] = 1 # Keep values inside normalized range for a correct comparison between heat maps

            # prepare cell density map for saving:
            cmapQ = plt.get_cmap('jet')
            A = cmapQ(new_imarray)

            fig, ax = plt.subplots()
            # assign colorbar:
            norm = matplotlib.colors.Normalize(vmin=0, vmax=max_val_pos)  # cm_lim) 
            plt.imshow(A)
            cb = fig.colorbar(plt.cm.ScalarMappable(norm, cmap='jet'), ax = ax, orientation = orient)

            # save positive cell density map:
            plt.title('Positive Cell Density Map')
            plt.savefig(pos_pp_im)
            cb.remove()
            plt.close("all")
        else:
            print("Normalized positive cell density map already exists, skipping.")

        # generate the ratio cell density map
        if not os.path.isfile(ratio_pp_im):
            print("Generating ratio cell density map.")
            neg_im = Image.open(HM_file_neg)
            width, height = neg_im.size
            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'
            neg_imarray = np.array(neg_im)
            pos_im = Image.open(HM_file_pos)
            pos_imarray = np.array(pos_im)
            for k in range(np.shape(neg_imarray)[0]):
                for l in range(np.shape(neg_imarray)[1]):
                    denominator = neg_imarray[k, l] + pos_imarray[k, l]
                    # if denominator is 0, assign a default value
                    if denominator == 0:
                        neg_imarray[k, l] = 0.0001 
                    else:
                        neg_imarray[k, l] = pos_imarray[k, l] / denominator
                    if neg_imarray[k, l] < 0.0001:
                        neg_imarray[k, l] = 0.0001
                    elif neg_imarray[k, l] > 1:
                        neg_imarray[k, l] = 1
                    elif math.isnan(neg_imarray[k, l]):
                        neg_imarray[k, l] = 0.0001
            max_rat = np.max(neg_imarray[neg_imarray<1])
            # only take into account foreground pixels
            relevant_values = neg_imarray[neg_imarray > 0] 
            n_relval = len(relevant_values)
            adjusted_n_relval = round(n_relval*0.95)
            sorted_relval = sorted(relevant_values)
            cm_lim = max(sorted_relval[:adjusted_n_relval])
            # max_val_neg = 500
            # normalize with obtained value
            neg_imarray = neg_imarray/cm_lim # imarray/max_val_neg # /cm_lim 
            # keep values inside normalized range for a correct comparison between heat maps
            neg_imarray[neg_imarray>1] = 1 
            # prepare cell density map for saving:
            cmapQ = plt.get_cmap('jet')
            A = cmapQ(neg_imarray)

            fig, ax = plt.subplots()
            # assign colorbar:
            norm = matplotlib.colors.Normalize(vmin=0, vmax=cm_lim) 
            plt.imshow(A)
            cb = fig.colorbar(plt.cm.ScalarMappable(norm, cmap='jet'), ax = ax, orientation = orient)

            # save the ratio cell density map:
            plt.title('Positive Negative Ratio Map')
            plt.savefig(ratio_pp_im)
            cb.remove()
            plt.close("all")
        else:
            print("Normalized ratio map already exists, skipping.")
    else:
        print(f"Required cell density map files not found for slide ID: {slide_id}. Skipping.")

# %% CREATE SUMMARY STATISTICS
# save the results to a csv file
results_df.to_csv(result_dir + 'HM_counts_res.csv', index=False)

summary_df = pd.DataFrame(columns = ['variable', 'label', 'mean', 'sd', 'median', 'minimum', 'maximum'])

summary_points = ['Positive', 'Pos_Density', 'Negative', 'Neg_Density', 'Pos_Percentage', 'Density']
y_units = {'Positive': 'Number of cells','Pos_Density': 'Number of cells per mm^2', 'Negative': 'Number of cells', 'Neg_Density': 'Number of cells per mm^2',
           'Pos_Percentage': 'Percentage', 'Density': 'Number of cells per mm^2'}
res_df = pd.read_csv(result_dir + 'HM_counts_res.csv')
label_list = np.unique(res_df['label'].tolist())

for sp in summary_points:
    box_data = []
    for label in label_list:
        sp_array = res_df[sp].loc[res_df['label'] == label]
        sp_array = sp_array[~np.isnan(sp_array)]
        box_data.append(sp_array) 
        sp_mean = round(np.mean(sp_array), 2)
        sp_sd = round(np.std(sp_array), 2)
        sp_median = round(np.median(sp_array), 2)
        sp_min = round(np.min(sp_array), 2)
        sp_max = round(np.max(sp_array), 2)
        # summary statistics 
        summary_df.loc[len(summary_df)] = [sp, label, sp_mean, sp_sd, sp_median, sp_min, sp_max]
    
    # boxplots for each summary point per diagnosis
    sns.set_style("whitegrid", {'axes.grid': False})
    plt.figure(figsize=(10, 6))
    plt.gca().set_facecolor('white')
    flierprops = dict(marker='D', markerfacecolor='darkgrey', markersize=5, linestyle='none')
    boxplot = sns.boxplot(x='label', y=sp, data=res_df, flierprops=flierprops)
    plt.title(f'{sp} across all diagnoses')
    plt.xlabel('Diagnosis')
    plt.ylabel(y_units[sp])
    plt.tight_layout()
    plt.savefig(result_dir + sp + '_BoxPlot.png')
    plt.close()

# summary statistics 
summary_df.to_csv(result_dir + 'Summary_statistics.csv', index=False)
# %%
