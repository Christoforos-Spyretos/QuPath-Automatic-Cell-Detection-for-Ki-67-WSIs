# %% IMPORTS
import json
import os
import numpy as np
import math
import pandas as pd
import argparse
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image
from mpl_toolkits.axes_grid1 import make_axes_locatable

# %% ARGUMENT PARSING
parser = argparse.ArgumentParser(description='Create summary ratios and density maps.')
parser.add_argument('--maps_dir', type=str, default=False, help='Directory of the cell density maps generated by QuPath.')
parser.add_argument('--data_dir', type=str, default=False, help='Directory of the project data')
parser.add_argument('--area_path', type=str, default=False, help='Path to Area.txt which is saved under the Results folder.')
parser.add_argument('--csv_path', type=str, required=True, help='Path to the WSI dataframe CSV file')
parser.add_argument('--WSIs_dir', type=str, default=False, help='Directory of the folder where the WSIs exist.')
parser.add_argument('--norm_maps_dir', type=str, default=False, help='Directory to save the normalized cell density maps.')
parser.add_argument('--result_dir', type=str, default=False, help='Directory to save the summary tables and graphs.')
args = parser.parse_args()

# %% DIRECTORIES & FILES NEEDED FOR THE ANALYSIS
maps_dir = args.maps_dir

data_dir = args.data_dir

csv_path = args.csv_path
# check if the CSV file exists
if not os.path.isfile(csv_path):
    raise FileNotFoundError(f"The specified CSV file does not exist: {csv_path}")

area_path = args.area_path
# check if the Area.txt file exists
if not os.path.isfile(area_path):
    raise FileNotFoundError(f"The specified Area.txt file does not exist: {area_path}")

WSI_df = pd.read_csv(csv_path)

WSIs_dir = args.WSIs_dir

norm_maps_dir = args.norm_maps_dir
# create the directory to save the normalised maps if it does not exist
if not os.path.exists(norm_maps_dir):
    os.makedirs(norm_maps_dir)

result_dir = args.result_dir
# create the directory to save the results if it does not exist
if not os.path.exists(result_dir):
    os.makedirs(result_dir)

# get the area and total detections
annotation_df = pd.read_csv(area_path,names=['name', 'detections', 'area'],delimiter=";",index_col=False)

# %% RETRIEVE INFORMATION FROM JSON FILES 
file_list = [f for f in os.listdir(data_dir) if os.path.isdir(os.path.join(data_dir,f))]
WSIs = os.listdir(WSIs_dir)

# data frame to store the results
results_df = pd.DataFrame(columns = ['case_id', 'slide_id', 'label', 'Positive_Cell_Count', 'Positive_Cell_Density', 'Negative_Cell_Count', 'Negative_Cell_Density', 'Ki-67 LI', 'Cell_Density'])

proc_l = len(file_list)
proc = -1
failed_list = []
failed_ann = []
for folder in file_list:
    proc += 1
    proc_perc = round(proc/proc_l*100, 2)
    print('Progress: ' + str(proc_perc) + '%') 
    print('Processing image ' + str(proc) + ' of ' + str(proc_l))
    with open(data_dir + '/' + folder + '/server.json', 'r') as s_file:
        server_data = json.load(s_file)
        slide_id = server_data['builder']['metadata']['name'][:-4]
        case_id = slide_id.split('___')[0]
    
    # Convert slide_id to int to match CSV data type
    try:
        slide_id_lookup = int(slide_id)
    except ValueError:
        # If conversion fails, keep as string (for cases with non-numeric IDs)
        slide_id_lookup = slide_id
    
    label = WSI_df['label'].loc[WSI_df['slide_id']==slide_id_lookup].values[0]
   
    print('Reading data from image ' + slide_id + ':')
    with open(data_dir + '/' + folder + '/summary.json', 'r') as file:
        data = json.load(file)
        detection_data = data['hierarchy']['detectionClassificationCounts']
        if 'Positive' not in detection_data.keys() and 'Negative' not in detection_data.keys():
            print('The slide has not been properly segmented yet, skipping.')
            failed_list.append(slide_id)
            continue
        
        # calculate the Ki-67 LI
        pos_cell_count = detection_data.get('Positive', 0)
        neg_cell_count = detection_data.get('Negative', 0)
        
        # Check if there are any cells detected
        if pos_cell_count + neg_cell_count == 0:
            print('No cells detected in this slide, skipping.')
            failed_list.append(slide_id)
            continue
        
        # round ratio to 2 decimal places
        ki67_li = round(pos_cell_count / (pos_cell_count + neg_cell_count), 2)
        
        for WSI in WSIs:
            WSI_name = WSI.split('.')[0]
            if slide_id in WSI_name:
                slide_file_name = WSI
                print('Found the corresponding WSI file: ' + slide_file_name)
                break

    try:
        annAreamm = annotation_df['area'].loc[annotation_df['name'] == slide_file_name].values[0]*0.000001
        numdet = annotation_df['detections'].loc[annotation_df['name'] == slide_file_name].values[0]
        cells_smm = numdet/annAreamm
        pos_cell_dens = pos_cell_count/annAreamm
        neg_cell_dens = neg_cell_count/annAreamm
    except:
        print('Could not find any annotation data.')
        failed_ann.append(slide_file_name)
    else:
        print("Area of the segmented tissue: " + str(annAreamm))
        print("Total number of detections: " + str(numdet))
        print('Number of detections per mm^2: ' + str(cells_smm))
    
    results_df.loc[len(results_df)] = [case_id, slide_id, label, pos_cell_count, pos_cell_dens, neg_cell_count, neg_cell_dens, ki67_li*100, cells_smm] 
    print('Positive cell count: ' + str(pos_cell_count))
    print('Negative cell count: ' + str(neg_cell_count))
    print('Positive to negative ratio: ' + str(ki67_li))

# %% GENERATE THE NORMALISED AND RATIO CELL DENSITY MAPS
    # get the cell density maps generated by QuPath
    HM_file_neg = maps_dir + '/' + slide_id + '_NegDMap.tif'
    HM_file_pos = maps_dir + '/' + slide_id + '_PosDMap.tif'

    failed_cell_density_list = []

    # check if both cell density map files exist before proceeding
    if os.path.isfile(HM_file_neg) and os.path.isfile(HM_file_pos):
        neg_pp_im = norm_maps_dir + '/' + slide_id + '_Neg_Cell_Dens_Map.png'
        pos_pp_im = norm_maps_dir + '/' + slide_id + '_Pos_Cell_Dens_Map.png'
        ratio_pp_im = norm_maps_dir + '/' + slide_id + '_Ki-67_LI_Map.png'

        # generate the normalised negative cell density map
        if not os.path.isfile(neg_pp_im):
            print("Generating normalized negative cell density map.")
            # get the raw grayscale negative cell density map
            im_neg = Image.open(HM_file_neg)
            width, height = im_neg.size

            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'

            # normalize 
            imarray_neg = np.array(im_neg)
            cm_lim_neg = np.max(imarray_neg)
            new_imarray_neg = imarray_neg/cm_lim_neg
            # keep values inside normalized range for a correct comparison between heat maps
            new_imarray_neg[new_imarray_neg>1] = 1 

            # colorise the negative cell density map
            cmapQ = plt.get_cmap('jet')
            A_neg = cmapQ(new_imarray_neg)

            # convert dark blue background to white
            A_neg[new_imarray_neg == 0] = [1, 1, 1, 1]

            # plot and save normalised negative cell density map
            fig, ax = plt.subplots()
            im = ax.imshow(A_neg)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_title('Negative Cell Density Map')
            divider = make_axes_locatable(ax)
            if orient == 'vertical':
                cax = divider.append_axes("right", size="5%", pad=0.20)
            else:
                cax = divider.append_axes("bottom", size="5%", pad=0.20)
            norm = matplotlib.colors.Normalize(vmin=0, vmax=neg_cell_dens)
            cb = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap='jet'), cax=cax, orientation=orient, shrink=1.0)
            plt.title('Negative Cell Density Map')
            plt.savefig(neg_pp_im)
            cb.remove()
            plt.close("all")

            # mask of the negative cell density map
            A_neg_blue_mask = A_neg
            A_neg_blue_mask[np.any(A_neg_blue_mask[:, :, :3] != [1, 1, 1], axis=2)] = [0, 0, 1, 1]

        else:
            print("Normalized negative cell density map already exists, skipping.")

        # generate the normalised positive cell density map
        if not os.path.isfile(pos_pp_im):
            print("Generating normalized positive cell density map.")
            # get the raw grayscale positive cell density map
            im_pos = Image.open(HM_file_pos)

            width, height = im_pos.size
            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'

            # normalise
            imarray_pos = np.array(im_pos)
            cm_lim_pos = np.max(imarray_pos)
            new_imarray_pos = imarray_pos/cm_lim_pos
            # keep values inside normalized range for a correct comparison between heat maps
            new_imarray_pos[new_imarray_pos>1] = 1

            # colorise
            cmapQ = plt.get_cmap('jet')
            A_pos = cmapQ(new_imarray_pos)

            # convert dark blue background to white
            A_pos[new_imarray_pos == 0] = [1, 1, 1, 1]

            new_A_pos = A_pos
            white_mask = np.all(new_A_pos[:, :, :3] == [1, 1, 1], axis=2)
            new_A_pos[white_mask] = A_neg_blue_mask[white_mask]

            # plot and save normalised positive cell density map   
            fig, ax = plt.subplots()
            im = ax.imshow(new_A_pos)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_title('Positive Cell Density Map')
            divider = make_axes_locatable(ax)
            if orient == 'vertical':
                cax = divider.append_axes("right", size="5%", pad=0.20)
            else:
                cax = divider.append_axes("bottom", size="5%", pad=0.20)
            norm = matplotlib.colors.Normalize(vmin=0, vmax=pos_cell_dens)
            cb = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap='jet'), cax=cax, orientation=orient, shrink=1.0)
            plt.savefig(pos_pp_im)
            cb.remove()
            plt.close("all")
        else:
            print("Normalized positive cell density map already exists, skipping.")

        # generate the Ki-67 LI map
        if not os.path.isfile(ratio_pp_im):
            print("Generating ratio cell density map.")
            neg_im = Image.open(HM_file_neg)
            width, height = neg_im.size
            # set color bar orientation depending on image dimensions:
            if width < height:
                orient = 'vertical'
            else:
                orient = 'horizontal'
            neg_imarray = np.array(neg_im)
            pos_im = Image.open(HM_file_pos)
            pos_imarray = np.array(pos_im)
            for k in range(np.shape(neg_imarray)[0]):
                for l in range(np.shape(neg_imarray)[1]):
                    denominator = neg_imarray[k, l] + pos_imarray[k, l]
                    # if denominator is 0, assign a default value
                    if denominator == 0:
                        neg_imarray[k, l] = 0.0001 
                    else:
                        neg_imarray[k, l] = pos_imarray[k, l] / denominator
                    if neg_imarray[k, l] < 0.0001:
                        neg_imarray[k, l] = 0.0001
                    elif neg_imarray[k, l] > 1:
                        neg_imarray[k, l] = 1
                    elif math.isnan(neg_imarray[k, l]):
                        neg_imarray[k, l] = 0.0001

            # only take into account foreground pixels
            relevant_values = neg_imarray[neg_imarray > 0] 
            n_relval = len(relevant_values)
            adjusted_n_relval = round(n_relval*0.95)
            sorted_relval = sorted(relevant_values)
            min_cm_lim = 0.03
            cm_lim = max(max(sorted_relval[:adjusted_n_relval]), min_cm_lim)
            # normalize with obtained value
            neg_imarray = neg_imarray/cm_lim 
            # keep values inside normalized range for a correct comparison between heat maps
            neg_imarray[neg_imarray>1] = 1 

            # colorise
            cmapQ = plt.get_cmap('jet')
            A_ki67_li = cmapQ(neg_imarray)

            # convert dark blue background to white
            dark_blue = [0, 0, 0.5, 1] # RGBA values for dark blue
            white = [1, 1, 1, 1] # RGBA values for white
            A_ki67_li[
                (A_ki67_li[:, :, 0] == dark_blue[0]) & 
                (A_ki67_li[:, :, 1] == dark_blue[1]) & 
                (A_ki67_li[:, :, 2] == dark_blue[2]) & 
                (A_ki67_li[:, :, 3] == dark_blue[3])
                ] = white

            new_A_ki67_li = A_ki67_li
            white_mask = np.all(new_A_ki67_li[:, :, :3] == [1, 1, 1], axis=2)
            new_A_ki67_li[white_mask] = A_neg_blue_mask[white_mask]

            # plot and save the ki-67 li map
            fig, ax = plt.subplots()
            im = ax.imshow(new_A_ki67_li)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_title('Ki-67 LI Map')
            divider = make_axes_locatable(ax)
            if orient == 'vertical':
                cax = divider.append_axes("right", size="5%", pad=0.20)
            else:
                cax = divider.append_axes("bottom", size="5%", pad=0.20)
            norm = matplotlib.colors.Normalize(vmin=0, vmax=ki67_li)
            cb = plt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap='jet'), cax=cax, orientation=orient, shrink=1.0)
            plt.savefig(ratio_pp_im)
            cb.remove()
            plt.close("all")
        else:
            print("Normalized Ki-67 LI map already exists, skipping.")
    else:
        print(f"Required cell density map files not found for slide ID: {slide_id}. Skipping.")

# %% CREATE SUMMARY STATISTICS
# save the results to a csv file
results_df.to_csv(os.path.join(result_dir, 'summary_results.csv'), index=False)

statistics_df = pd.DataFrame(columns = ['variable', 'label', 'mean', 'sd', 'median', 'minimum', 'maximum'])

summary_points = ['Positive_Cell_Count', 'Positive_Cell_Density', 'Negative_Cell_Count', 'Negative_Cell_Density', 'Ki-67 LI', 'Cell_Density']

y_units = {'Positive_Cell_Count': 'Number of positive cells',
           'Positive_Cell_Density': 'Number of positive cells per mm^2', 
           'Negative_Cell_Count': 'Number of negative cells', 
           'Negative_Cell_Density': 'Number of negative cells per mm^2',
           'Ki-67 LI': 'Ki-67 LI', 
           'Cell_Density': 'Number of cells per mm^2'}

res_df = pd.read_csv(os.path.join(result_dir, 'summary_results.csv'))
label_list = np.unique(res_df['label'].tolist())

# summary table and boxplots
for sp in summary_points:
    box_data = []
    for label in label_list:
        sp_array = res_df[sp].loc[res_df['label'] == label]
        sp_array = sp_array[~np.isnan(sp_array)]
        box_data.append(sp_array) 
        sp_mean = round(np.mean(sp_array), 2)
        sp_sd = round(np.std(sp_array), 2)
        sp_median = round(np.median(sp_array), 2)
        sp_min = round(np.min(sp_array), 2)
        sp_max = round(np.max(sp_array), 2)
        # summary statistics 
        statistics_df.loc[len(statistics_df)] = [sp, label, sp_mean, sp_sd, sp_median, sp_min, sp_max]
    
    # boxplots
    palette = sns.color_palette("deep", 10)
    custom_colors = [palette[9]]
    palette = sns.color_palette(custom_colors * len(label_list))

    sns.set_style("whitegrid", {'axes.grid': False})
    plt.figure(figsize=(10, 6))
    plt.gca().set_facecolor('white')
    flierprops = dict(marker='D', markerfacecolor='darkgrey', markersize=5, linestyle='none')
    boxplot = sns.boxplot(
        x='label', 
        y=sp, 
        data=res_df, 
        flierprops=flierprops, 
        palette=palette, 
        linewidth=2
    )
    plt.title(f'{sp} across all diagnoses')
    plt.xlabel('Diagnosis')
    plt.ylabel(y_units[sp])
    plt.tight_layout()
    plt.savefig(os.path.join(result_dir,sp + '_BoxPlot.png'))
    plt.close()

# summary statistics 
statistics_df.to_csv(os.path.join(result_dir, 'summary_statistics.csv'), index=False)

# %%
